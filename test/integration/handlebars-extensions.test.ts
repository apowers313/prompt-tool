import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as os from 'os';
import { TemplateEngine } from '../../src/template/template-engine.js';
import { Config } from '../../src/types/config.js';
import { Prompt } from '../../src/types/prompt.js';

describe('Handlebars Extensions Integration', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'pt-test-'));
  });

  afterEach(async () => {
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('inline extensions in templates', () => {
    it('should apply inline helper to template processing', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('shout', function(text) {
                return text.toUpperCase() + '!!!';
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'The message is: {{shout "hello world"}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('The message is: HELLO WORLD!!!');
    });

    it('should apply multiple inline extensions', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('prefix', function(text) {
                return '[PREFIX] ' + text;
              });
            `
          },
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('suffix', function(text) {
                return text + ' [SUFFIX]';
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: '{{suffix (prefix "content")}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('[PREFIX] content [SUFFIX]');
    });

    it('should apply inline partials to template processing', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerPartial('signature', '\\n---\\nGenerated by {{author}}');
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'Main content{{> signature}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      // Mock the context to provide the author value
      const result = await engine.processTemplate(prompt.content, prompt);
      // The template will use {{author}} but it won't be defined, so let's use a different test
      const testPrompt: Prompt = {
        ...prompt,
        content: 'Main content{{> signature author="Test Author"}}'
      };
      const result2 = await engine.processTemplate(testPrompt.content, testPrompt);

      expect(result2).toContain('Main content\n---\nGenerated by Test Author');
    });
  });

  describe('file-based extensions in templates', () => {
    it('should load and apply file-based helper', async () => {
      const helperPath = path.join(tempDir, 'capitalize.js');
      await fs.writeFile(helperPath, `
        module.exports = function(Handlebars) {
          Handlebars.registerHelper('capitalize', function(text) {
            return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
          });
        };
      `);

      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'file',
            path: helperPath
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'Hello {{capitalize "wORLD"}}!',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('Hello World!');
    });

    it('should resolve relative paths from config directory', async () => {
      const extensionsDir = path.join(tempDir, 'extensions');
      await fs.mkdir(extensionsDir, { recursive: true });
      
      const helperPath = path.join(extensionsDir, 'math.js');
      await fs.writeFile(helperPath, `
        module.exports = function(Handlebars) {
          Handlebars.registerHelper('add', function(a, b) {
            return a + b;
          });
          Handlebars.registerHelper('multiply', function(a, b) {
            return a * b;
          });
        };
      `);

      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'file',
            path: './extensions/math.js'
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: '5 + 3 = {{add 5 3}}, 5 * 3 = {{multiply 5 3}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config, tempDir);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('5 + 3 = 8, 5 * 3 = 15');
    });
  });

  describe('extensions with existing helpers', () => {
    it('should work alongside built-in helpers', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('wrap', function(text) {
                return '<<' + text + '>>';
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'Date: {{date}}, Wrapped: {{wrap "content"}}, User: {{username}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      // Check that built-in helpers still work
      // Date helper uses different format
      expect(result).toContain('Date: ');
      expect(result).toContain('Wrapped: <<content>>');
      expect(result).toContain('User: ');
    });

    it('should allow extensions to use other helpers', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('timestampedMessage', function(message) {
                const date = new Date().toISOString().split('T')[0];
                return '[' + date + '] ' + message;
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: '{{timestampedMessage "System initialized"}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toMatch(/\[\d{4}-\d{2}-\d{2}\] System initialized/);
    });
  });

  describe('error handling', () => {
    it('should handle errors in inline extensions gracefully', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: 'This is invalid JavaScript {'
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'Hello world',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      await expect(engine.processTemplate(prompt.content, prompt)).rejects.toThrow();
    });

    it('should handle missing file extensions gracefully', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'file',
            path: path.join(tempDir, 'non-existent.js')
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: 'Hello world',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      await expect(engine.processTemplate(prompt.content, prompt)).rejects.toThrow();
    });
  });

  describe('complex template scenarios', () => {
    it('should handle extensions with variables and input helpers', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerHelper('formatCode', function(lang, code) {
                return '\\\`\\\`\\\`' + lang + '\\n' + code + '\\n\\\`\\\`\\\`';
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: '{{formatCode "javascript" "console.log(\\"Hello\\");"}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('```javascript\nconsole.log("Hello");\n```');
    });

    it('should handle nested partials and helpers', async () => {
      const config: Config = {
        promptDirs: [],
        handlebarsExtensions: [
          {
            type: 'inline',
            value: `
              Handlebars.registerPartial('header', '# {{title}}\\n{{description}}');
              Handlebars.registerPartial('section', '## {{sectionTitle}}\\n{{> header}}');
              Handlebars.registerHelper('upper', function(text) {
                return text.toUpperCase();
              });
            `
          }
        ]
      };

      const prompt: Prompt = {
        title: 'Test Prompt',
        content: '{{> section sectionTitle=(upper "overview") title="Main Title" description="This is a description"}}',
        tags: [],
        variables: [],
        path: 'test.md'
      };

      const engine = new TemplateEngine(config);
      const result = await engine.processTemplate(prompt.content, prompt);

      expect(result).toBe('## OVERVIEW\n# Main Title\nThis is a description');
    });
  });
});